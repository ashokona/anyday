'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const path = require('path');
const debug = require('debug')('email-templates');
const fs = require('fs-extra');
const htmlToText = require('html-to-text');
const I18N = require('@ladjs/i18n');
const autoBind = require('auto-bind');
const nodemailer = require('nodemailer');
const consolidate = require('consolidate');
const previewEmail = require('preview-email');
const _ = require('lodash');
const Promise = require('bluebird');

const getPaths = require('get-paths');
const juiceResources = require('juice-resources-promise');

class Email {
  constructor(config = {}) {
    debug('config passed %O', config);

    // 2.x backwards compatible support
    if (config.juiceOptions) {
      config.juiceResources = config.juiceOptions;
      delete config.juiceOptions;
    }
    if (config.disableJuice) {
      config.juice = false;
      delete config.disableJuice;
    }

    this.config = _.merge({
      views: {
        // directory where email templates reside
        root: path.resolve('emails'),
        options: {
          // default file extension for template
          extension: 'pug',
          map: {},
          engineSource: consolidate
        },
        // locals to pass to templates for rendering
        locals: {
          // pretty is automatically set to `false` for subject/text
          pretty: true
        }
      },
      // <https://nodemailer.com/message/>
      message: {},
      send: !['development', 'test'].includes(process.env.NODE_ENV),
      preview: process.env.NODE_ENV === 'development',
      // <https://github.com/ladjs/i18n>
      // set to an object to configure and enable it
      i18n: false,
      // pass a custom render function if necessary
      render: this.render.bind(this),
      // force text-only rendering of template (disregards template folder)
      textOnly: false,
      // <https://github.com/werk85/node-html-to-text>
      htmlToText: {
        ignoreImage: true
      },
      // <https://github.com/Automattic/juice>
      juice: true,
      juiceResources: {
        preserveImportant: true,
        webResources: {
          relativeTo: path.resolve('build')
        }
      },
      // pass a transport configuration object or a transport instance
      // (e.g. an instance is created via `nodemailer.createTransport`)
      // <https://nodemailer.com/transports/>
      transport: {}
    }, config);

    if (!_.isFunction(this.config.transport.sendMail)) this.config.transport = nodemailer.createTransport(this.config.transport);

    debug('transformed config %O', this.config);

    autoBind(this);
  }

  // shorthand use of `juiceResources` with the config
  // (mainly for custom renders like from a database)
  juiceResources(html) {
    return juiceResources(html, this.config.juiceResources);
  }

  // a simple helper function that gets the actual file path for the template
  getTemplatePath(view) {
    var _this = this;

    return new Promise((() => {
      var _ref = _asyncToGenerator(function* (resolve, reject) {
        try {
          const paths = yield getPaths(_this.config.views.root, view, _this.config.views.options.extension);
          const filePath = path.resolve(_this.config.views.root, paths.rel);
          resolve({ filePath, paths });
        } catch (err) {
          reject(err);
        }
      });

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    })());
  }

  // returns true or false if a template exists
  // (uses same look-up approach as `render` function)
  templateExists(view) {
    var _this2 = this;

    return new Promise((() => {
      var _ref2 = _asyncToGenerator(function* (resolve) {
        try {
          var _ref3 = yield _this2.getTemplatePath(view);

          const filePath = _ref3.filePath;

          const stats = yield fs.stat(filePath);
          if (!stats.isFile()) throw new Error(`${filePath} was not a file`);
          resolve(true);
        } catch (err) {
          debug('templateExists', err);
          resolve(false);
        }
      });

      return function (_x3) {
        return _ref2.apply(this, arguments);
      };
    })());
  }

  // promise version of consolidate's render
  // inspired by koa-views and re-uses the same config
  // <https://github.com/queckezz/koa-views>
  render(view, locals) {
    var _this3 = this;

    return new Promise((() => {
      var _ref4 = _asyncToGenerator(function* (resolve, reject) {
        try {
          var _config$views$options = _this3.config.views.options;
          const map = _config$views$options.map,
                engineSource = _config$views$options.engineSource;

          var _ref5 = yield _this3.getTemplatePath(view);

          const filePath = _ref5.filePath,
                paths = _ref5.paths;

          if (paths.ext === 'html' && !map) {
            const res = yield fs.readFile(filePath, 'utf8');
            resolve(res);
          } else {
            const engineName = map && map[paths.ext] ? map[paths.ext] : paths.ext;
            const render = engineSource[engineName];
            if (!engineName || !render) return reject(new Error(`Engine not found for the ".${paths.ext}" file extension`));

            if (_.isObject(_this3.config.i18n)) {
              const i18n = new I18N(Object.assign({}, _this3.config.i18n, {
                register: locals
              }));

              // support `locals.user.last_locale`
              // (e.g. for <https://lad.js.org>)
              if (_.isObject(locals.user) && _.isString(locals.user.last_locale)) locals.locale = locals.user.last_locale;

              if (_.isString(locals.locale)) i18n.setLocale(locals.locale);
            }

            // TODO: convert this to a promise based version
            render(filePath, locals, function (err, res) {
              if (err) return reject(err);
              // transform the html with juice using remote paths
              // google now supports media queries
              // https://developers.google.com/gmail/design/reference/supported_css
              if (!_this3.config.juice) return resolve(res);
              _this3.juiceResources(res).then(resolve).catch(reject);
            });
          }
        } catch (err) {
          reject(err);
        }
      });

      return function (_x4, _x5) {
        return _ref4.apply(this, arguments);
      };
    })());
  }

  send(options = {}) {
    var _this4 = this;

    options = Object.assign({
      template: '',
      message: {},
      locals: {}
    }, options);

    var _options = options;
    let template = _options.template,
        message = _options.message,
        locals = _options.locals;


    const attachments = message.attachments || this.config.message.attachments || [];

    message = _.defaultsDeep({}, _.omit(this.config.message, 'attachments'), _.omit(message, 'attachments'));
    locals = _.defaultsDeep({}, this.config.views.locals, locals);

    if (attachments) message.attachments = attachments;

    debug('template %s', template);
    debug('message %O', message);
    debug('locals (keys only): %O', Object.keys(locals));

    return new Promise((() => {
      var _ref6 = _asyncToGenerator(function* (resolve, reject) {
        try {
          let subjectTemplateExists = false;
          let htmlTemplateExists = false;
          let textTemplateExists = false;

          const promises = [_this4.templateExists(`${template}/subject`), _this4.templateExists(`${template}/html`), _this4.templateExists(`${template}/text`)];

          if (template) {
            ;

            var _ref7 = yield Promise.all(promises);

            var _ref8 = _slicedToArray(_ref7, 3);

            subjectTemplateExists = _ref8[0];
            htmlTemplateExists = _ref8[1];
            textTemplateExists = _ref8[2];
          }if (!message.subject && subjectTemplateExists) message.subject = yield _this4.config.render(`${template}/subject`, Object.assign({}, locals, { pretty: false }));

          if (!message.html && htmlTemplateExists) message.html = yield _this4.config.render(`${template}/html`, locals);

          if ((!htmlTemplateExists || !_this4.config.htmlToText) && !message.text && textTemplateExists) message.text = yield _this4.config.render(`${template}/text`, Object.assign({}, locals, { pretty: false }));else if (_this4.config.htmlToText && message.html)
            // we'd use nodemailer-html-to-text plugin
            // but we really don't need to support cid
            // <https://github.com/andris9/nodemailer-html-to-text>
            message.text = htmlToText.fromString(message.html, _this4.config.htmlToText);

          // if we only want a text-based version of the email
          if (_this4.config.textOnly) delete message.html;

          if (_this4.config.preview) {
            debug('using `preview-email` to preview email');
            yield previewEmail(message);
          }

          if (!_this4.config.send) {
            debug('send disabled so we are ensuring JSONTransport');
            // <https://github.com/nodemailer/nodemailer/issues/798>
            // if (this.config.transport.name !== 'JSONTransport')
            _this4.config.transport = nodemailer.createTransport({
              jsonTransport: true
            });
          }

          const res = yield _this4.config.transport.sendMail(message);
          debug('message sent');
          resolve(res);
        } catch (err) {
          reject(err);
        }
      });

      return function (_x6, _x7) {
        return _ref6.apply(this, arguments);
      };
    })());
  }
}

module.exports = Email;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsImRlYnVnIiwiZnMiLCJodG1sVG9UZXh0IiwiSTE4TiIsImF1dG9CaW5kIiwibm9kZW1haWxlciIsImNvbnNvbGlkYXRlIiwicHJldmlld0VtYWlsIiwiXyIsIlByb21pc2UiLCJnZXRQYXRocyIsImp1aWNlUmVzb3VyY2VzIiwiRW1haWwiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsImp1aWNlT3B0aW9ucyIsImRpc2FibGVKdWljZSIsImp1aWNlIiwibWVyZ2UiLCJ2aWV3cyIsInJvb3QiLCJyZXNvbHZlIiwib3B0aW9ucyIsImV4dGVuc2lvbiIsIm1hcCIsImVuZ2luZVNvdXJjZSIsImxvY2FscyIsInByZXR0eSIsIm1lc3NhZ2UiLCJzZW5kIiwiaW5jbHVkZXMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJwcmV2aWV3IiwiaTE4biIsInJlbmRlciIsImJpbmQiLCJ0ZXh0T25seSIsImlnbm9yZUltYWdlIiwicHJlc2VydmVJbXBvcnRhbnQiLCJ3ZWJSZXNvdXJjZXMiLCJyZWxhdGl2ZVRvIiwidHJhbnNwb3J0IiwiaXNGdW5jdGlvbiIsInNlbmRNYWlsIiwiY3JlYXRlVHJhbnNwb3J0IiwiaHRtbCIsImdldFRlbXBsYXRlUGF0aCIsInZpZXciLCJyZWplY3QiLCJwYXRocyIsImZpbGVQYXRoIiwicmVsIiwiZXJyIiwidGVtcGxhdGVFeGlzdHMiLCJzdGF0cyIsInN0YXQiLCJpc0ZpbGUiLCJFcnJvciIsImV4dCIsInJlcyIsInJlYWRGaWxlIiwiZW5naW5lTmFtZSIsImlzT2JqZWN0IiwiT2JqZWN0IiwiYXNzaWduIiwicmVnaXN0ZXIiLCJ1c2VyIiwiaXNTdHJpbmciLCJsYXN0X2xvY2FsZSIsImxvY2FsZSIsInNldExvY2FsZSIsInRoZW4iLCJjYXRjaCIsInRlbXBsYXRlIiwiYXR0YWNobWVudHMiLCJkZWZhdWx0c0RlZXAiLCJvbWl0Iiwia2V5cyIsInN1YmplY3RUZW1wbGF0ZUV4aXN0cyIsImh0bWxUZW1wbGF0ZUV4aXN0cyIsInRleHRUZW1wbGF0ZUV4aXN0cyIsInByb21pc2VzIiwiYWxsIiwic3ViamVjdCIsInRleHQiLCJmcm9tU3RyaW5nIiwianNvblRyYW5zcG9ydCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE1BQU1BLE9BQU9DLFFBQVEsTUFBUixDQUFiO0FBQ0EsTUFBTUMsUUFBUUQsUUFBUSxPQUFSLEVBQWlCLGlCQUFqQixDQUFkO0FBQ0EsTUFBTUUsS0FBS0YsUUFBUSxVQUFSLENBQVg7QUFDQSxNQUFNRyxhQUFhSCxRQUFRLGNBQVIsQ0FBbkI7QUFDQSxNQUFNSSxPQUFPSixRQUFRLGFBQVIsQ0FBYjtBQUNBLE1BQU1LLFdBQVdMLFFBQVEsV0FBUixDQUFqQjtBQUNBLE1BQU1NLGFBQWFOLFFBQVEsWUFBUixDQUFuQjtBQUNBLE1BQU1PLGNBQWNQLFFBQVEsYUFBUixDQUFwQjtBQUNBLE1BQU1RLGVBQWVSLFFBQVEsZUFBUixDQUFyQjtBQUNBLE1BQU1TLElBQUlULFFBQVEsUUFBUixDQUFWO0FBQ0EsTUFBTVUsVUFBVVYsUUFBUSxVQUFSLENBQWhCOztBQUVBLE1BQU1XLFdBQVdYLFFBQVEsV0FBUixDQUFqQjtBQUNBLE1BQU1ZLGlCQUFpQlosUUFBUSx5QkFBUixDQUF2Qjs7QUFFQSxNQUFNYSxLQUFOLENBQVk7QUFDVkMsY0FBWUMsU0FBUyxFQUFyQixFQUF5QjtBQUN2QmQsVUFBTSxrQkFBTixFQUEwQmMsTUFBMUI7O0FBRUE7QUFDQSxRQUFJQSxPQUFPQyxZQUFYLEVBQXlCO0FBQ3ZCRCxhQUFPSCxjQUFQLEdBQXdCRyxPQUFPQyxZQUEvQjtBQUNBLGFBQU9ELE9BQU9DLFlBQWQ7QUFDRDtBQUNELFFBQUlELE9BQU9FLFlBQVgsRUFBeUI7QUFDdkJGLGFBQU9HLEtBQVAsR0FBZSxLQUFmO0FBQ0EsYUFBT0gsT0FBT0UsWUFBZDtBQUNEOztBQUVELFNBQUtGLE1BQUwsR0FBY04sRUFBRVUsS0FBRixD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SDtBQUNBO0FBQ0E7QUFDQW5CLG9CQUFRMEQsSUFBUixHQUFlcEYsV0FBV3FGLFVBQVgsQ0FDYjNELFFBQVFtQixJQURLLEVBRWIsT0FBS2pDLE1BQUwsQ0FBWVosVUFGQyxDQUFmOztBQUtGO0FBQ0EsY0FBSSxPQUFLWSxNQUFMLENBQVl3QixRQUFoQixFQUEwQixPQUFPVixRQUFRbUIsSUFBZjs7QUFFMUIsY0FBSSxPQUFLakMsTUFBTCxDQUFZb0IsT0FBaEIsRUFBeUI7QUFDdkJsQyxrQkFBTSx3Q0FBTjtBQUNBLGtCQUFNTyxhQUFhcUIsT0FBYixDQUFOO0FBQ0Q7O0FBRUQsY0FBSSxDQUFDLE9BQUtkLE1BQUwsQ0FBWWUsSUFBakIsRUFBdUI7QUFDckI3QixrQkFBTSxnREFBTjtBQUNBO0FBQ0E7QUFDQSxtQkFBS2MsTUFBTCxDQUFZNkIsU0FBWixHQUF3QnRDLFdBQVd5QyxlQUFYLENBQTJCO0FBQ2pEMEMsNkJBQWU7QUFEa0MsYUFBM0IsQ0FBeEI7QUFHRDs7QUFFRCxnQkFBTTNCLE1BQU0sTUFBTSxPQUFLL0MsTUFBTCxDQUFZNkIsU0FBWixDQUFzQkUsUUFBdEIsQ0FBK0JqQixPQUEvQixDQUFsQjtBQUNBNUIsZ0JBQU0sY0FBTjtBQUNBcUIsa0JBQVF3QyxHQUFSO0FBQ0QsU0FqRUQsQ0FpRUUsT0FBT1AsR0FBUCxFQUFZO0FBQ1pKLGlCQUFPSSxHQUFQO0FBQ0Q7QUFDRixPQXJFTTs7QUFBQTtBQUFBO0FBQUE7QUFBQSxTQUFQO0FBc0VEO0FBclFTOztBQXdRWm1DLE9BQU9DLE9BQVAsR0FBaUI5RSxLQUFqQiIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VtYWlsLXRlbXBsYXRlcycpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcy1leHRyYScpO1xuY29uc3QgaHRtbFRvVGV4dCA9IHJlcXVpcmUoJ2h0bWwtdG8tdGV4dCcpO1xuY29uc3QgSTE4TiA9IHJlcXVpcmUoJ0BsYWRqcy9pMThuJyk7XG5jb25zdCBhdXRvQmluZCA9IHJlcXVpcmUoJ2F1dG8tYmluZCcpO1xuY29uc3Qgbm9kZW1haWxlciA9IHJlcXVpcmUoJ25vZGVtYWlsZXInKTtcbmNvbnN0IGNvbnNvbGlkYXRlID0gcmVxdWlyZSgnY29uc29saWRhdGUnKTtcbmNvbnN0IHByZXZpZXdFbWFpbCA9IHJlcXVpcmUoJ3ByZXZpZXctZW1haWwnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xuXG5jb25zdCBnZXRQYXRocyA9IHJlcXVpcmUoJ2dldC1wYXRocycpO1xuY29uc3QganVpY2VSZXNvdXJjZXMgPSByZXF1aXJlKCdqdWljZS1yZXNvdXJjZXMtcHJvbWlzZScpO1xuXG5jbGFzcyBFbWFpbCB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgZGVidWcoJ2NvbmZpZyBwYXNzZWQgJU8nLCBjb25maWcpO1xuXG4gICAgLy8gMi54IGJhY2t3YXJkcyBjb21wYXRpYmxlIHN1cHBvcnRcbiAgICBpZiAoY29uZmlnLmp1aWNlT3B0aW9ucykge1xuICAgICAgY29uZmlnLmp1aWNlUmVzb3VyY2VzID0gY29uZmlnLmp1aWNlT3B0aW9ucztcbiAgICAgIGRlbGV0ZSBjb25maWcuanVpY2VPcHRpb25zO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmRpc2FibGVKdWljZSkge1xuICAgICAgY29uZmlnLmp1aWNlID0gZmFsc2U7XG4gICAgICBkZWxldGUgY29uZmlnLmRpc2FibGVKdWljZTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmZpZyA9IF8ubWVyZ2UoXG4gICAgICB7XG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgLy8gZGlyZWN0b3J5IHdoZXJlIGVtYWlsIHRlbXBsYXRlcyByZXNpZGVcbiAgICAgICAgICByb290OiBwYXRoLnJlc29sdmUoJ2VtYWlscycpLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgZmlsZSBleHRlbnNpb24gZm9yIHRlbXBsYXRlXG4gICAgICAgICAgICBleHRlbnNpb246ICdwdWcnLFxuICAgICAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgICAgIGVuZ2luZVNvdXJjZTogY29uc29saWRhdGVcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIGxvY2FscyB0byBwYXNzIHRvIHRlbXBsYXRlcyBmb3IgcmVuZGVyaW5nXG4gICAgICAgICAgbG9jYWxzOiB7XG4gICAgICAgICAgICAvLyBwcmV0dHkgaXMgYXV0b21hdGljYWxseSBzZXQgdG8gYGZhbHNlYCBmb3Igc3ViamVjdC90ZXh0XG4gICAgICAgICAgICBwcmV0dHk6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIDxodHRwczovL25vZGVtYWlsZXIuY29tL21lc3NhZ2UvPlxuICAgICAgICBtZXNzYWdlOiB7fSxcbiAgICAgICAgc2VuZDogIVsnZGV2ZWxvcG1lbnQnLCAndGVzdCddLmluY2x1ZGVzKHByb2Nlc3MuZW52Lk5PREVfRU5WKSxcbiAgICAgICAgcHJldmlldzogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcsXG4gICAgICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vbGFkanMvaTE4bj5cbiAgICAgICAgLy8gc2V0IHRvIGFuIG9iamVjdCB0byBjb25maWd1cmUgYW5kIGVuYWJsZSBpdFxuICAgICAgICBpMThuOiBmYWxzZSxcbiAgICAgICAgLy8gcGFzcyBhIGN1c3RvbSByZW5kZXIgZnVuY3Rpb24gaWYgbmVjZXNzYXJ5XG4gICAgICAgIHJlbmRlcjogdGhpcy5yZW5kZXIuYmluZCh0aGlzKSxcbiAgICAgICAgLy8gZm9yY2UgdGV4dC1vbmx5IHJlbmRlcmluZyBvZiB0ZW1wbGF0ZSAoZGlzcmVnYXJkcyB0ZW1wbGF0ZSBmb2xkZXIpXG4gICAgICAgIHRleHRPbmx5OiBmYWxzZSxcbiAgICAgICAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS93ZXJrODUvbm9kZS1odG1sLXRvLXRleHQ+XG4gICAgICAgIGh0bWxUb1RleHQ6IHtcbiAgICAgICAgICBpZ25vcmVJbWFnZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvanVpY2U+XG4gICAgICAgIGp1aWNlOiB0cnVlLFxuICAgICAgICBqdWljZVJlc291cmNlczoge1xuICAgICAgICAgIHByZXNlcnZlSW1wb3J0YW50OiB0cnVlLFxuICAgICAgICAgIHdlYlJlc291cmNlczoge1xuICAgICAgICAgICAgcmVsYXRpdmVUbzogcGF0aC5yZXNvbHZlKCdidWlsZCcpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBwYXNzIGEgdHJhbnNwb3J0IGNvbmZpZ3VyYXRpb24gb2JqZWN0IG9yIGEgdHJhbnNwb3J0IGluc3RhbmNlXG4gICAgICAgIC8vIChlLmcuIGFuIGluc3RhbmNlIGlzIGNyZWF0ZWQgdmlhIGBub2RlbWFpbGVyLmNyZWF0ZVRyYW5zcG9ydGApXG4gICAgICAgIC8vIDxodHRwczovL25vZGVtYWlsZXIuY29tL3RyYW5zcG9ydHMvPlxuICAgICAgICB0cmFuc3BvcnQ6IHt9XG4gICAgICB9LFxuICAgICAgY29uZmlnXG4gICAgKTtcblxuICAgIGlmICghXy5pc0Z1bmN0aW9uKHRoaXMuY29uZmlnLnRyYW5zcG9ydC5zZW5kTWFpbCkpXG4gICAgICB0aGlzLmNvbmZpZy50cmFuc3BvcnQgPSBub2RlbWFpbGVyLmNyZWF0ZVRyYW5zcG9ydCh0aGlzLmNvbmZpZy50cmFuc3BvcnQpO1xuXG4gICAgZGVidWcoJ3RyYW5zZm9ybWVkIGNvbmZpZyAlTycsIHRoaXMuY29uZmlnKTtcblxuICAgIGF1dG9CaW5kKHRoaXMpO1xuICB9XG5cbiAgLy8gc2hvcnRoYW5kIHVzZSBvZiBganVpY2VSZXNvdXJjZXNgIHdpdGggdGhlIGNvbmZpZ1xuICAvLyAobWFpbmx5IGZvciBjdXN0b20gcmVuZGVycyBsaWtlIGZyb20gYSBkYXRhYmFzZSlcbiAganVpY2VSZXNvdXJjZXMoaHRtbCkge1xuICAgIHJldHVybiBqdWljZVJlc291cmNlcyhodG1sLCB0aGlzLmNvbmZpZy5qdWljZVJlc291cmNlcyk7XG4gIH1cblxuICAvLyBhIHNpbXBsZSBoZWxwZXIgZnVuY3Rpb24gdGhhdCBnZXRzIHRoZSBhY3R1YWwgZmlsZSBwYXRoIGZvciB0aGUgdGVtcGxhdGVcbiAgZ2V0VGVtcGxhdGVQYXRoKHZpZXcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGF0aHMgPSBhd2FpdCBnZXRQYXRocyhcbiAgICAgICAgICB0aGlzLmNvbmZpZy52aWV3cy5yb290LFxuICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgdGhpcy5jb25maWcudmlld3Mub3B0aW9ucy5leHRlbnNpb25cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLnJlc29sdmUodGhpcy5jb25maWcudmlld3Mucm9vdCwgcGF0aHMucmVsKTtcbiAgICAgICAgcmVzb2x2ZSh7IGZpbGVQYXRoLCBwYXRocyB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIHJldHVybnMgdHJ1ZSBvciBmYWxzZSBpZiBhIHRlbXBsYXRlIGV4aXN0c1xuICAvLyAodXNlcyBzYW1lIGxvb2stdXAgYXBwcm9hY2ggYXMgYHJlbmRlcmAgZnVuY3Rpb24pXG4gIHRlbXBsYXRlRXhpc3RzKHZpZXcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgcmVzb2x2ZSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGZpbGVQYXRoIH0gPSBhd2FpdCB0aGlzLmdldFRlbXBsYXRlUGF0aCh2aWV3KTtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBmcy5zdGF0KGZpbGVQYXRoKTtcbiAgICAgICAgaWYgKCFzdGF0cy5pc0ZpbGUoKSkgdGhyb3cgbmV3IEVycm9yKGAke2ZpbGVQYXRofSB3YXMgbm90IGEgZmlsZWApO1xuICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGRlYnVnKCd0ZW1wbGF0ZUV4aXN0cycsIGVycik7XG4gICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gcHJvbWlzZSB2ZXJzaW9uIG9mIGNvbnNvbGlkYXRlJ3MgcmVuZGVyXG4gIC8vIGluc3BpcmVkIGJ5IGtvYS12aWV3cyBhbmQgcmUtdXNlcyB0aGUgc2FtZSBjb25maWdcbiAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9xdWVja2V6ei9rb2Etdmlld3M+XG4gIHJlbmRlcih2aWV3LCBsb2NhbHMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBtYXAsIGVuZ2luZVNvdXJjZSB9ID0gdGhpcy5jb25maWcudmlld3Mub3B0aW9ucztcbiAgICAgICAgY29uc3QgeyBmaWxlUGF0aCwgcGF0aHMgfSA9IGF3YWl0IHRoaXMuZ2V0VGVtcGxhdGVQYXRoKHZpZXcpO1xuICAgICAgICBpZiAocGF0aHMuZXh0ID09PSAnaHRtbCcgJiYgIW1hcCkge1xuICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZzLnJlYWRGaWxlKGZpbGVQYXRoLCAndXRmOCcpO1xuICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBlbmdpbmVOYW1lID0gbWFwICYmIG1hcFtwYXRocy5leHRdID8gbWFwW3BhdGhzLmV4dF0gOiBwYXRocy5leHQ7XG4gICAgICAgICAgY29uc3QgcmVuZGVyID0gZW5naW5lU291cmNlW2VuZ2luZU5hbWVdO1xuICAgICAgICAgIGlmICghZW5naW5lTmFtZSB8fCAhcmVuZGVyKVxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBFbmdpbmUgbm90IGZvdW5kIGZvciB0aGUgXCIuJHtwYXRocy5leHR9XCIgZmlsZSBleHRlbnNpb25gXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAoXy5pc09iamVjdCh0aGlzLmNvbmZpZy5pMThuKSkge1xuICAgICAgICAgICAgY29uc3QgaTE4biA9IG5ldyBJMThOKFxuICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbmZpZy5pMThuLCB7XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXI6IGxvY2Fsc1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gc3VwcG9ydCBgbG9jYWxzLnVzZXIubGFzdF9sb2NhbGVgXG4gICAgICAgICAgICAvLyAoZS5nLiBmb3IgPGh0dHBzOi8vbGFkLmpzLm9yZz4pXG4gICAgICAgICAgICBpZiAoXy5pc09iamVjdChsb2NhbHMudXNlcikgJiYgXy5pc1N0cmluZyhsb2NhbHMudXNlci5sYXN0X2xvY2FsZSkpXG4gICAgICAgICAgICAgIGxvY2Fscy5sb2NhbGUgPSBsb2NhbHMudXNlci5sYXN0X2xvY2FsZTtcblxuICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcobG9jYWxzLmxvY2FsZSkpIGkxOG4uc2V0TG9jYWxlKGxvY2Fscy5sb2NhbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRPRE86IGNvbnZlcnQgdGhpcyB0byBhIHByb21pc2UgYmFzZWQgdmVyc2lvblxuICAgICAgICAgIHJlbmRlcihmaWxlUGF0aCwgbG9jYWxzLCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0aGUgaHRtbCB3aXRoIGp1aWNlIHVzaW5nIHJlbW90ZSBwYXRoc1xuICAgICAgICAgICAgLy8gZ29vZ2xlIG5vdyBzdXBwb3J0cyBtZWRpYSBxdWVyaWVzXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9nbWFpbC9kZXNpZ24vcmVmZXJlbmNlL3N1cHBvcnRlZF9jc3NcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25maWcuanVpY2UpIHJldHVybiByZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICB0aGlzLmp1aWNlUmVzb3VyY2VzKHJlcylcbiAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHNlbmQob3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7XG4gICAgICAgIHRlbXBsYXRlOiAnJyxcbiAgICAgICAgbWVzc2FnZToge30sXG4gICAgICAgIGxvY2Fsczoge31cbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcblxuICAgIGxldCB7IHRlbXBsYXRlLCBtZXNzYWdlLCBsb2NhbHMgfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBhdHRhY2htZW50cyA9XG4gICAgICBtZXNzYWdlLmF0dGFjaG1lbnRzIHx8IHRoaXMuY29uZmlnLm1lc3NhZ2UuYXR0YWNobWVudHMgfHwgW107XG5cbiAgICBtZXNzYWdlID0gXy5kZWZhdWx0c0RlZXAoXG4gICAgICB7fSxcbiAgICAgIF8ub21pdCh0aGlzLmNvbmZpZy5tZXNzYWdlLCAnYXR0YWNobWVudHMnKSxcbiAgICAgIF8ub21pdChtZXNzYWdlLCAnYXR0YWNobWVudHMnKVxuICAgICk7XG4gICAgbG9jYWxzID0gXy5kZWZhdWx0c0RlZXAoe30sIHRoaXMuY29uZmlnLnZpZXdzLmxvY2FscywgbG9jYWxzKTtcblxuICAgIGlmIChhdHRhY2htZW50cykgbWVzc2FnZS5hdHRhY2htZW50cyA9IGF0dGFjaG1lbnRzO1xuXG4gICAgZGVidWcoJ3RlbXBsYXRlICVzJywgdGVtcGxhdGUpO1xuICAgIGRlYnVnKCdtZXNzYWdlICVPJywgbWVzc2FnZSk7XG4gICAgZGVidWcoJ2xvY2FscyAoa2V5cyBvbmx5KTogJU8nLCBPYmplY3Qua2V5cyhsb2NhbHMpKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgc3ViamVjdFRlbXBsYXRlRXhpc3RzID0gZmFsc2U7XG4gICAgICAgIGxldCBodG1sVGVtcGxhdGVFeGlzdHMgPSBmYWxzZTtcbiAgICAgICAgbGV0IHRleHRUZW1wbGF0ZUV4aXN0cyA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW1xuICAgICAgICAgIHRoaXMudGVtcGxhdGVFeGlzdHMoYCR7dGVtcGxhdGV9L3N1YmplY3RgKSxcbiAgICAgICAgICB0aGlzLnRlbXBsYXRlRXhpc3RzKGAke3RlbXBsYXRlfS9odG1sYCksXG4gICAgICAgICAgdGhpcy50ZW1wbGF0ZUV4aXN0cyhgJHt0ZW1wbGF0ZX0vdGV4dGApXG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKHRlbXBsYXRlKVxuICAgICAgICAgIFtcbiAgICAgICAgICAgIHN1YmplY3RUZW1wbGF0ZUV4aXN0cyxcbiAgICAgICAgICAgIGh0bWxUZW1wbGF0ZUV4aXN0cyxcbiAgICAgICAgICAgIHRleHRUZW1wbGF0ZUV4aXN0c1xuICAgICAgICAgIF0gPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAgICAgaWYgKCFtZXNzYWdlLnN1YmplY3QgJiYgc3ViamVjdFRlbXBsYXRlRXhpc3RzKVxuICAgICAgICAgIG1lc3NhZ2Uuc3ViamVjdCA9IGF3YWl0IHRoaXMuY29uZmlnLnJlbmRlcihcbiAgICAgICAgICAgIGAke3RlbXBsYXRlfS9zdWJqZWN0YCxcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIGxvY2FscywgeyBwcmV0dHk6IGZhbHNlIH0pXG4gICAgICAgICAgKTtcblxuICAgICAgICBpZiAoIW1lc3NhZ2UuaHRtbCAmJiBodG1sVGVtcGxhdGVFeGlzdHMpXG4gICAgICAgICAgbWVzc2FnZS5odG1sID0gYXdhaXQgdGhpcy5jb25maWcucmVuZGVyKGAke3RlbXBsYXRlfS9odG1sYCwgbG9jYWxzKTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgKCFodG1sVGVtcGxhdGVFeGlzdHMgfHwgIXRoaXMuY29uZmlnLmh0bWxUb1RleHQpICYmXG4gICAgICAgICAgIW1lc3NhZ2UudGV4dCAmJlxuICAgICAgICAgIHRleHRUZW1wbGF0ZUV4aXN0c1xuICAgICAgICApXG4gICAgICAgICAgbWVzc2FnZS50ZXh0ID0gYXdhaXQgdGhpcy5jb25maWcucmVuZGVyKFxuICAgICAgICAgICAgYCR7dGVtcGxhdGV9L3RleHRgLFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxzLCB7IHByZXR0eTogZmFsc2UgfSlcbiAgICAgICAgICApO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbmZpZy5odG1sVG9UZXh0ICYmIG1lc3NhZ2UuaHRtbClcbiAgICAgICAgICAvLyB3ZSdkIHVzZSBub2RlbWFpbGVyLWh0bWwtdG8tdGV4dCBwbHVnaW5cbiAgICAgICAgICAvLyBidXQgd2UgcmVhbGx5IGRvbid0IG5lZWQgdG8gc3VwcG9ydCBjaWRcbiAgICAgICAgICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL2FuZHJpczkvbm9kZW1haWxlci1odG1sLXRvLXRleHQ+XG4gICAgICAgICAgbWVzc2FnZS50ZXh0ID0gaHRtbFRvVGV4dC5mcm9tU3RyaW5nKFxuICAgICAgICAgICAgbWVzc2FnZS5odG1sLFxuICAgICAgICAgICAgdGhpcy5jb25maWcuaHRtbFRvVGV4dFxuICAgICAgICAgICk7XG5cbiAgICAgICAgLy8gaWYgd2Ugb25seSB3YW50IGEgdGV4dC1iYXNlZCB2ZXJzaW9uIG9mIHRoZSBlbWFpbFxuICAgICAgICBpZiAodGhpcy5jb25maWcudGV4dE9ubHkpIGRlbGV0ZSBtZXNzYWdlLmh0bWw7XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnByZXZpZXcpIHtcbiAgICAgICAgICBkZWJ1ZygndXNpbmcgYHByZXZpZXctZW1haWxgIHRvIHByZXZpZXcgZW1haWwnKTtcbiAgICAgICAgICBhd2FpdCBwcmV2aWV3RW1haWwobWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLnNlbmQpIHtcbiAgICAgICAgICBkZWJ1Zygnc2VuZCBkaXNhYmxlZCBzbyB3ZSBhcmUgZW5zdXJpbmcgSlNPTlRyYW5zcG9ydCcpO1xuICAgICAgICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vbm9kZW1haWxlci9ub2RlbWFpbGVyL2lzc3Vlcy83OTg+XG4gICAgICAgICAgLy8gaWYgKHRoaXMuY29uZmlnLnRyYW5zcG9ydC5uYW1lICE9PSAnSlNPTlRyYW5zcG9ydCcpXG4gICAgICAgICAgdGhpcy5jb25maWcudHJhbnNwb3J0ID0gbm9kZW1haWxlci5jcmVhdGVUcmFuc3BvcnQoe1xuICAgICAgICAgICAganNvblRyYW5zcG9ydDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jb25maWcudHJhbnNwb3J0LnNlbmRNYWlsKG1lc3NhZ2UpO1xuICAgICAgICBkZWJ1ZygnbWVzc2FnZSBzZW50Jyk7XG4gICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVtYWlsO1xuIl19